#include "adjacency_list.h"

#include "verbose.h"
#include <algorithm>

// 生成三角网格的无向边邻接表：
template <typename Index, typename IndexVector>
IGL_INLINE void igl::adjacency_list(const Eigen::MatrixBase<Index>& tris,  std::vector<std::vector<IndexVector> >& adjList,
    bool sorted)
{
   int versCount = tris.maxCoeff() + 1;
   int trisCount = tris.rows();
  adjList.clear(); 
  adjList.resize(versCount);

  for(int i = 0; i < trisCount; i++)
  {
    for(int j = 0; j < tris.cols(); j++)                 // j == 0 时，index1 == vaIdx, index2 == vbIdx，
    {
      int index1 = tris(i, j);
      int index2 = tris(i, (j+1)%tris.cols());
      adjList.at(index1).push_back(index2);
      adjList.at(index2).push_back(index1);
    }
  }
 
  // 去除重复元素；
  for(int i = 0; i < versCount; ++i)
  {
    std::sort(adjList[i].begin(), adjList[i].end());
    adjList[i].erase(std::unique(adjList[i].begin(), adjList[i].end()), adjList[i].end());
  }
  
  // If needed, sort every VV
  if (sorted)
  {
    // Loop over faces
    
    // for every vertex v store a set of ordered edges not incident to v that belongs to triangle incident on v.
    std::vector<std::vector<std::vector<int> > > SR; 
    SR.resize(adjList.size());
    
    for(int i = 0; i < tris.rows(); i++)
    {
      // Loop over this face
      for(int j = 0; j < tris.cols(); j++)
      {
        // Get indices of edge: s --> d
        int s = tris(i,j);
        int d = tris(i, (j+1)%tris.cols());
        // Get index of opposing vertex v
        int v = tris(i, (j+2)%tris.cols());
        
        std::vector<int> e(2);
        e[0] = d;
        e[1] = v;
        SR[s].push_back(e);
      }
    }
    
    for(int v=0; v<(int)SR.size();++v)
    {
      std::vector<IndexVector>& vv = adjList.at(v);
      std::vector<std::vector<int> >& sr = SR[v];      
      std::vector<std::vector<int> > pn = sr;
      
      // Compute previous/next for every element in sr
      for(int i=0;i<(int)sr.size();++i)
      {
        int a = sr[i][0];
        int b = sr[i][1];
        
        // search for previous
        int p = -1;
        for(int j=0;j<(int)sr.size();++j)
          if(sr[j][1] == a)
            p = j;
        pn[i][0] = p;
        
        // search for next
        int n = -1;
        for(int j=0;j<(int)sr.size();++j)
          if(sr[j][0] == b)
            n = j;
        pn[i][1] = n;
        
      }
      
      // assume manifoldness (look for beginning of a single chain)
      int c = 0;
      for(int j=0; j<=(int)sr.size();++j)
        if (pn[c][0] != -1)
          c = pn[c][0];
      
      if (pn[c][0] == -1) // border case
      {
        // finally produce the new vv relation
        for(int j=0; j<(int)sr.size();++j)
        {
          vv[j] = sr[c][0];
          if (pn[c][1] != -1)
            c = pn[c][1];
        }
        vv.back() = sr[c][1];
      }
      else
      {
        // finally produce the new vv relation
        for(int j=0; j<(int)sr.size();++j)
        {
          vv[j] = sr[c][0];          
          c = pn[c][1];
        }
      }
    }
  }
}


template <typename Index>
IGL_INLINE void igl::adjacency_list(
  const std::vector<std::vector<Index> > & tris,
  std::vector<std::vector<Index> >& adjList)
{
  adjList.clear();
  
  // Find maxCoeff
  Index maxCoeff = 0;
  for(const auto &vec : tris)
  {
    for(int coeff : vec)
    {
      maxCoeff = std::max(coeff, maxCoeff);
    }
  }
  adjList.resize(maxCoeff + 1);
  
  // Loop over faces
  for(int i = 0;i<tris.size();i++)
  {
    // Loop over this face
    for(int j = 0;j<tris[i].size();j++)
    {
      // Get indices of edge: s --> d
      int s = tris[i][j];
      int d = tris[i][(j+1)%tris[i].size()];
      adjList.at(s).push_back(d);
      adjList.at(d).push_back(s);
    }
  }
  
  // Remove duplicates
  for(int i=0; i<(int)adjList.size();++i)
  {
    std::sort(adjList[i].begin(), adjList[i].end());
    adjList[i].erase(std::unique(adjList[i].begin(), adjList[i].end()), adjList[i].end());
  }
  
}


#ifdef IGL_STATIC_LIBRARY
// Explicit template instantiation
// generated by autoexplicit.sh
template void igl::adjacency_list<Eigen::Matrix<int, -1, 2, 0, -1, 2>, int>(Eigen::MatrixBase<Eigen::Matrix<int, -1, 2, 0, -1, 2> > const&, std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >&, bool);
// generated by autoexplicit.sh
template void igl::adjacency_list<Eigen::Matrix<int, -1, -1, 0, -1, -1>, int>(Eigen::MatrixBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> > const&, std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >&, bool);
template void igl::adjacency_list<Eigen::Matrix<int, -1, 3, 0, -1, 3>, int>(Eigen::MatrixBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > const&, std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >&, bool);
template void igl::adjacency_list<class Eigen::Matrix<int, -1, -1, 0, -1, -1>, unsigned int>(class Eigen::MatrixBase<class Eigen::Matrix<int, -1, -1, 0, -1, -1> > const &, class std::vector<class std::vector<unsigned int, class std::allocator<unsigned int> >, class std::allocator<class std::vector<unsigned int, class std::allocator<unsigned int> > > > &, bool);
template void igl::adjacency_list<int>(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > const&, std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >&);
#endif
